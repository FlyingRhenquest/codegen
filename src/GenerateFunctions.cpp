/**
 * Copyright 2025 Bruce Ide
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 * This is a line-by-line preprocessor that reads lines of code from
 * your program and emits lines of code out. If it encounters the
 * annotations [[genGetSetMethods]] or [[genCerealLoadSave]], it will
 * NOT emit those lines and instead will emit getters and setters or
 * cereal serialziation functions instead. If the class they're currently
 * in has not tagged any members to generate getter or setters or
 * serialization functions, nothing will be emitted in the place of those
 * lines. Getters and setters must currently be generated as inline
 * methods.
 *
 * An index.json file must exist and be passed to this program on the
 * command line.
 */

#include <boost/program_options.hpp>
#include <fr/codegen/data.h>
#include <fr/codegen/drivers.h>
#include <fr/codegen/parser.h>
#include <fr/codegen/LblFilter.h>
#include <fr/codegen/LblMiniParser.h>
#include <fr/codegen/LblEmitFunctions.h>
#include <fstream>
#include <iostream>
#include <map>
#include <memory>
#include <string>
#include <vector>

void printHelp(boost::program_options::options_description& desc) {
  std::cout << "This program reads C++ header code line by line, looking for" << std::endl;
  std::cout << "[[genGetSetMethods]] and [[genCerealLoadSave]] tags, which" << std::endl;
  std::cout << "exist in the code on a line by themselves. When one of these" << std::endl;
  std::cout << "is encoutered, it will be replaced by functions dictated by" << std::endl;
  std::cout << "annotation tags in the class when the class is indexed by" << std::endl;
  std::cout << "IndexCode." << std::endl;
  std::cout << desc << std::endl;    
}

int main(int argc, char *argv[]) {
  using namespace fr::codegen;
  
  // Header to read
  std::string header;
  // output file
  std::string output;
  // Index file
  std::string index;
  
  boost::program_options::options_description desc("Options:");
  boost::program_options::variables_map vm;

  desc.add_options()
    ("header,h",
     boost::program_options::value<std::string>(&header),
     "Header to add functions to")
    ("index,i",
     boost::program_options::value<std::string>(&index),
     "json index generated by IndexCode")
    ("output,o",
     boost::program_options::value<std::string>(&output),
     "Output file to write modified header to")
    ;

  boost::program_options::store(boost::program_options::parse_command_line(argc, argv, desc), vm);
  boost::program_options::notify(vm);

  if (!vm.count("header") || !vm.count("output")) {
    printHelp(desc);
    exit(1);
  }

  std::map<std::string, std::shared_ptr<EnumData>> enumMap;
  std::map<std::string, std::shared_ptr<ClassData>> classMap;

  std::cout << "Reading Index..." << std::endl;

  std::ifstream indexStream(index);
  {
    cereal::JSONInputArchive archive(indexStream);
    archive(enumMap);
    archive(classMap);
  }

  std::cout << "Setting up line by line processor...." << std::endl;

  // if we add more methods to the chain we just need to keep subscribing to
  // the previous one. Only one filter should subscribe to anything else
  // for code generation purposes. You can subscribe other things to
  // these objects for stuff like telemetry and debugging if you need to.
  // So just shuffle stuff in before the LblWriter.
  
  LblReader reader(header);
  
  fr::codegen::miniparser::LblMiniparser parser;
  parser.subscribeTo(reader);

  parser.classPush.connect([](const std::string& className) {
    std::cout << "Processing " << className << "...";
  });

  parser.classPop.connect([](){
    std::cout << "Done" << std::endl;
  });

  LblEmitGetSetMethods getSetEmitter(classMap);
  getSetEmitter.subscribeTo(parser);

  LblEmitCerealMethods cerealEmitter(classMap);
  cerealEmitter.subscribeTo(getSetEmitter);
  
  LblWriter writer(output);
  writer.subscribeTo(cerealEmitter);

  reader.process();

  std::cout << "Processing complete" << std::endl;
  exit(0);
  
}
