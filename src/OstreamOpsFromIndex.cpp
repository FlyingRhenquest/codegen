/**
 * Copyright 2025 Bruce Ide
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 *
 * This program reads an index generated by IndexFunctions and generates
 * ostream operators and to_string functions for all the enums in the
 * index.
 */

#include <algorithm>
#include <boost/program_options.hpp>
#include <fr/codegen/data.h>
#include <fr/codegen/drivers.h>
#include <fr/codegen/parser.h>
#include <fstream>
#include <iostream>
#include <map>
#include <memory>
#include <string>
#include <vector>

using EnumMap = std::map<std::string, std::shared_ptr<fr::codegen::EnumData>>;

void printHelp(boost::program_options::options_description &desc) {
  std::cout << std::endl;
  std::cout << "This program reads a json index generated by IndexCode and" << std::endl;
  std::cout << "generates ostream operators and to_string functions for all" << std::endl;
  std::cout << "the enums found in the index." << std::endl << std::endl;
  std::cout << "Usage: " << std::endl;
  std::cout << desc << std::endl << std::endl;
}

// Generate header file from enum map
void generateHeader(EnumMap enums, std::ofstream& stream) {
  stream << "/* This is generated code. Do not edit. Unless you REALLY want to */" << std::endl;
  stream << "#pragma once" << std::endl;
  stream << "#include <string>" << std::endl;
  stream << "#include <iostream>" << std::endl;
  std::vector<std::string> includedFiles;
  for (auto [name,ptr] : enums) {
    // Only include each unique file once
    if (std::find(includedFiles.begin(), includedFiles.end(), ptr->definedIn) == includedFiles.end()) {
      stream << "#include <" << ptr->definedIn << ">" << std::endl;
      includedFiles.push_back(ptr->definedIn);
    }
  }

  // Emit header definitions
  for (auto [name,ptr] : enums) {
    stream << "std::string to_string(const " << name << "& value);" << std::endl;
    stream << "std::ostream& operator<<(std::ostream& stream, const " << name << "& value);" << std::endl;
  }
}

// Generate CPP file -- needs header file name so it can included it, fortunately
// user passed it in
void generateSource(EnumMap enums, std::ofstream& stream, std::string headerFile) {
  stream << "/* This is generated code. Do not edit. Unless you REALLY want to */" << std::endl;
  stream << "#include \"" << headerFile << "\"" << std::endl;

  for (auto [name, ptr] : enums) {
    stream << "std::string to_string(const " << name << "& value) {" << std::endl;
    stream << "// Default value if not found" << std::endl;
    stream << "std::string ret(\"UKNOWN VALUE IN " << name << "\");" << std::endl;
    stream << "  switch(value) {" << std::endl;
    for(auto id : ptr->identifiers) {
      stream << "     case ";
        if (ptr->isClassEnum) {
          // If it's a class enum we need to include the enum namespace
          // and name, which name has, so we can just append the identifier
          // name after that
          stream << name << "::" << id;
        } else {
          // Otherwise we have to include the namespace the enum is defined
          // in but NOT the enum name
          if (ptr->namespaces.size()) {
            stream << ptr->enumNamespace() << "::";
          }
          stream << id;
        }
      stream << ":" << std::endl;
      stream << "       ret = \"";
      if (ptr->isClassEnum) {
        stream << name << "::" << id;
      } else {
        if (ptr->namespaces.size()) {
          stream << ptr->enumNamespace() << "::";
        }
        stream << id;
      }
      stream << "\";" << std::endl;
      stream << "       break;" << std::endl;
    }
    stream << "  }" << std::endl;
    stream << " return ret;" << std::endl;
    stream << "}" << std::endl << std::endl;
    stream << "std::ostream& operator<<(std::ostream& stream, const " << name << "& value) {" << std::endl;
    stream << "  stream << to_string(value);" << std::endl;
    stream << "  return stream;" << std::endl;
    stream << "}" << std::endl << std::endl;
  }
}

int main(int argc, char *argv[]) {
  EnumMap enums;
  std::string indexFile;
  std::string generateHeaderFile;
  std::string generateCppFile;
  
  boost::program_options::options_description desc("Options:");
  boost::program_options::variables_map vm;

  desc.add_options()
    ("index,i",
     boost::program_options::value<std::string>(&indexFile),
     "Index file generated by IndexCode")
    ("header,h",
     boost::program_options::value<std::string>(&generateHeaderFile),
     "Header file to generate")
    ("cpp,c",
     boost::program_options::value<std::string>(&generateCppFile),
     "Cpp file to generate")
    ;
  boost::program_options::store(boost::program_options::parse_command_line(argc, argv, desc), vm);
  boost::program_options::notify(vm);
  
  if (!vm.count("index") ||
      !vm.count("header") ||
      !vm.count("cpp")) {
    printHelp(desc);
    exit(1);
  }

  std::cout << "Reading index..." << std::endl;
  
  std::ifstream index(indexFile);
  {
    cereal::JSONInputArchive archive(index);
    archive(enums);
  }


  std::ofstream header(generateHeaderFile);
  std::ofstream cpp(generateCppFile);
  std::cout << "Generating "<< generateHeaderFile << std::endl;
  generateHeader(enums, header);
  std::cout << "Generating " << generateCppFile << std::endl;
  generateSource(enums, cpp, generateHeaderFile);
  std::cout << "Done" << std::endl;
  exit(0);
}
