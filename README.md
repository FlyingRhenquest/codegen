# Codegen

This is a little demo project that parses a small subset of C++ to extract
data from enums and classes.

This is not indended to be a production-ready project. Rather, it
demonstrates how to use boost::spirit::x3 for a somewhat complex
parser. The parser itself is fairly fragile at the moment. It does not
claim to conform 100% to the C++ standard for even the limited amount
of stuff that it does. It is a good jumping off point to push further
into C++ parsing and I do intend to add some more features to it.

If you want to use this project to generate code, it would be a good
idea to put the classes you want it to read in a header file
and keep them as simple as possible. If you look in the the
"Data.cpp" file in the test directory, that's what I'm testing
on right now. Your mileage may vary.

This project is licensed under Apache 2.0. If you do something interesting
with it, I'd love to hear about it!

# Built Applications

GenerateEnumFunctions - Parses a header file and generates enum
ostream operators and to_string functions. Consider this deprecated
as the data objects in data.h now have serialization functions we can
use to generate an index, and it's a lot easier to just index all the
headers you plan to use this code on and then generate code from the
index. The example project now uses this process with OstreamOpsFromIndex.

IndexCode - Reads header files you give it and generates a JSON index
of all the stuff it read. This includes class and enum data. You can
specify multiple header files with additional -h flags.

OstreamOpsFromIndex - Reads the enums out of the index and generates
ostream operators for them.

# CMake Instrumentation

When you install this package, the CMake instrumentation in 
cmake/CodegenFunctions.cmake. This currently includes two cmake
functions:

codegen\_index\_objects runs IndexCode on the specified objects
and generates a JSON index file.

codegen\_ostream\_operators runs OstreamOpsFromIndex and generates
ostream operators and to_string functions for your enums.

If you run make install with this project, a find\_package will
be installed, so that if you find\_package(FRCodegen), you
can use this instrumentation in your cmake file (The examples
in the examples directory do this.)

# Limitations

This code won't generate code for anonymous enums, enums embedded in
enums or enums embedded in classes. You can look in the tests directory
for a good idea of what it can handle at this time.

# Building

This program requires boost::spirit::x3, boost::program_options and
boost::signals2. If you have a fairly recent boost installed somehwere
that CMake can find it, you should be able to build it with:

```
mkdir /tmp/build
cd /tmp/build
cmake ~/sandbox/codegen
sudo make install
```
 
The example should be built separately once the GenerateEnumFunctions
program has been installed in your path:

```
 mkdir /tmp/build_examples
 cd /tmp/build_examples
 cmake ~/sandbox/codegen/examples/enum_example
 make
 ./example
```

If you modify the parser and rebuild GenerateEnumFunctions, you'll need
to rerun cmake for the examples. Currently the code generated by
the cmake instrumentation is not deleted if you run a make clean,
but will be overwritten by cmake whenever you run it.

If you want to build and run the tests, specify -DBUILD_TESTS=ON
in the cmake command line.

If you set CMAKE\_BUILD\_TYPE=DEBUG, this will enable the boost
spirit X3 XML debug output, which can be really handy for seeing
what your parser's doing.

# My Conclusions from this project

boost::spirit::x3 is actually pretty easy to use once you get over the
initial learning curve. Don't let the library intimidate you. It only
took me a couple of days to put this together and I had almost no 
experience with boost x3 prior to this.

It is best to develop your parser one X3 rule at a time and then write
a somewhat comprehensive test to validate that the rule is being
matched and processed the way you want it to be. Building parsers can
still be fairly tricky. If you have a language specification you're
working from, that can help immensely with laying out your token
definitions. I didn't bother to go check the C++ standard and instead
went from my own knowledge of the language, so this probably won't
conform 100% to the C++ standard. That wasn't really the point of the
exercise.

Documentation and forum support for this particuar library can be
somewhat iffy since you'll match like 3 other parser libraries that
boost contains when you're searching. One particular issue I ran
across was that tokens were being concatinated when I hit them
multiple times in the parser. So my first namespace test initially
returned the tokens "foo", "foobar" and "foobarbaz." Stack overflow
and Google's gemini AI suggested using x3::at to solve this problem,
but x3::at does not and apparently has never existed. The correct
solution was to reset the x3 context after storing the information I
need, like so:

 x3::_attr(ctx) = "";
 
This information was not documented anywhere, it just occurred to me
to try it.

If you just want to grab some tokens out of a text stream, check out
the signals exported in the ParserDriver object defined in parser.h.
Any number of things can subscribe to those signals to be notified of
specific events. This can make processing somewhat tricky, but it
can also let you isolate processing for specific tasks for much
neater encapsulation that would have been previously possible. The
namespace object and the enum data object in data.h are both interested
in namespaces, for example, but do their own processing based on the
information they receive. So unless I start breaking encapsulation
by copying redundant information across objects, I can be pretty
sure the namespace processing will always be correct. I can query that
object or a container of those objects when I need anything relating to
namespaces.

One quick note on boost signals2 signals; the signal handler runs in
the caller's thread. So your signal handler will block the parser
until the handler returns. If you need to do a significant amount of
processing and need real-time responses from other objects monitoring
the parser, you'll want to copy the data you receive and handle it in
a different thread. It's up to you to make a call on when the processing
in your signal handler crosses the "Too much to block the parser"
threshold, but it's always a good thing to be aware of when working
with boost signals2 signals. My media and media2 projects do a lot
of that sort of processing if you're curious what the code looks
like for handling that.

# Future Plans

* Write some functions to generate APIs for Python with nanobind
  and emscripten with embind.
* You might notice that I parse some specific annotations in C++
  code which a C++ compiler should generally ignore. I'm planning
  to write some code to auto-generate getters and setters for objects
  and Cereal serialization functions as well! I will document these
  once I've done that.
* Write Python APIs (And maybe Emscripten ones too) for the data
  objects.
* Write python APIs for the Parser and Driver objects.
